<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>FlatBuffers: flatbuffers::FlatBufferBuilder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Roboto:300,400,400italic,500,500italic,700,700italic|Roboto+Mono:400,700" rel="stylesheet">
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea" style="height: 110px;">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="commonprojectlogo">
    <img alt="Logo" src="fpl_logo_small.png"/>
  </td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">FlatBuffers
   </div>
   <div style="font-size:12px;">
    An open source project by <a href="https://developers.google.com/games/#Tools">FPL</a>.
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classflatbuffers_1_1_flat_buffer_builder.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classflatbuffers_1_1_flat_buffer_builder-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">flatbuffers::FlatBufferBuilder Class Reference<div class="ingroups"><a class="el" href="group__flatbuffers__cpp__api.html">Flatbuffers_cpp_api</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Helper class to hold data needed in creation of a FlatBuffer.  
 <a href="classflatbuffers_1_1_flat_buffer_builder.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="flatbuffers_8h_source.html">flatbuffers.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Helper class to hold data needed in creation of a FlatBuffer. </p>
<p>To serialize data, you typically call one of the <code>Create*()</code> functions in the generated code, which in turn call a sequence of <code>StartTable</code>/ <code>PushElement</code>/<code>AddElement</code>/<code>EndTable</code>, or the builtin <code>CreateString</code>/ <code>CreateVector</code> functions. Do this is depth-first order to build up a tree to the root. <code>Finish()</code> wraps up the buffer ready for transport. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflatbuffers_1_1_flat_buffer_builder_1_1_field_loc.html">FieldLoc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflatbuffers_1_1_flat_buffer_builder_1_1_string_offset_compare.html">StringOffsetCompare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae94b94ba71ea0aeb2d9a98c43b713412"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#ae94b94ba71ea0aeb2d9a98c43b713412">Clear</a> ()</td></tr>
<tr class="memdesc:ae94b94ba71ea0aeb2d9a98c43b713412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all the state in this FlatBufferBuilder so it can be reused to construct another buffer.  <a href="#ae94b94ba71ea0aeb2d9a98c43b713412">More...</a><br /></td></tr>
<tr class="separator:ae94b94ba71ea0aeb2d9a98c43b713412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab478a645216d2d613fc7b7c29b0ff9d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="structflatbuffers_1_1_string.html">String</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#ab478a645216d2d613fc7b7c29b0ff9d1">CreateSharedString</a> (const char *str, size_t len)</td></tr>
<tr class="memdesc:ab478a645216d2d613fc7b7c29b0ff9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a string in the buffer, which can contain any binary data.  <a href="#ab478a645216d2d613fc7b7c29b0ff9d1">More...</a><br /></td></tr>
<tr class="separator:ab478a645216d2d613fc7b7c29b0ff9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb68613e5883dc4b8fff6cf7d1223d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="structflatbuffers_1_1_string.html">String</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a3eb68613e5883dc4b8fff6cf7d1223d7">CreateSharedString</a> (const char *str)</td></tr>
<tr class="memdesc:a3eb68613e5883dc4b8fff6cf7d1223d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a string in the buffer, which null-terminated.  <a href="#a3eb68613e5883dc4b8fff6cf7d1223d7">More...</a><br /></td></tr>
<tr class="separator:a3eb68613e5883dc4b8fff6cf7d1223d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e8ec7d1c8fbdc21b1c7047bbbe38d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="structflatbuffers_1_1_string.html">String</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a10e8ec7d1c8fbdc21b1c7047bbbe38d9">CreateSharedString</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a10e8ec7d1c8fbdc21b1c7047bbbe38d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a string in the buffer, which can contain any binary data.  <a href="#a10e8ec7d1c8fbdc21b1c7047bbbe38d9">More...</a><br /></td></tr>
<tr class="separator:a10e8ec7d1c8fbdc21b1c7047bbbe38d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840b769fbb4148f97d3eed266e4690c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="structflatbuffers_1_1_string.html">String</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a840b769fbb4148f97d3eed266e4690c3">CreateSharedString</a> (const <a class="el" href="structflatbuffers_1_1_string.html">String</a> *str)</td></tr>
<tr class="memdesc:a840b769fbb4148f97d3eed266e4690c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a string in the buffer, which can contain any binary data.  <a href="#a840b769fbb4148f97d3eed266e4690c3">More...</a><br /></td></tr>
<tr class="separator:a840b769fbb4148f97d3eed266e4690c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6f9df2a0366b540b24822414d92cbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="structflatbuffers_1_1_string.html">String</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#aec6f9df2a0366b540b24822414d92cbe">CreateString</a> (const char *str, size_t len)</td></tr>
<tr class="memdesc:aec6f9df2a0366b540b24822414d92cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a string in the buffer, which can contain any binary data.  <a href="#aec6f9df2a0366b540b24822414d92cbe">More...</a><br /></td></tr>
<tr class="separator:aec6f9df2a0366b540b24822414d92cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad93d113ac24e86ed04b5236b3f4c0c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="structflatbuffers_1_1_string.html">String</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#aad93d113ac24e86ed04b5236b3f4c0c5">CreateString</a> (const char *str)</td></tr>
<tr class="memdesc:aad93d113ac24e86ed04b5236b3f4c0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a string in the buffer, which is null-terminated.  <a href="#aad93d113ac24e86ed04b5236b3f4c0c5">More...</a><br /></td></tr>
<tr class="separator:aad93d113ac24e86ed04b5236b3f4c0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51db9083ac815eb81420b6d51f42154"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="structflatbuffers_1_1_string.html">String</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#ac51db9083ac815eb81420b6d51f42154">CreateString</a> (char *str)</td></tr>
<tr class="memdesc:ac51db9083ac815eb81420b6d51f42154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a string in the buffer, which is null-terminated.  <a href="#ac51db9083ac815eb81420b6d51f42154">More...</a><br /></td></tr>
<tr class="separator:ac51db9083ac815eb81420b6d51f42154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3af55e64f5cda9aefa38ac5287ef9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="structflatbuffers_1_1_string.html">String</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a8c3af55e64f5cda9aefa38ac5287ef9f">CreateString</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a8c3af55e64f5cda9aefa38ac5287ef9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a string in the buffer, which can contain any binary data.  <a href="#a8c3af55e64f5cda9aefa38ac5287ef9f">More...</a><br /></td></tr>
<tr class="separator:a8c3af55e64f5cda9aefa38ac5287ef9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3a955fbff1c69e944c3560460dd7a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="structflatbuffers_1_1_string.html">String</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a9a3a955fbff1c69e944c3560460dd7a6">CreateString</a> (flatbuffers::string_view str)</td></tr>
<tr class="memdesc:a9a3a955fbff1c69e944c3560460dd7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a string in the buffer, which can contain any binary data.  <a href="#a9a3a955fbff1c69e944c3560460dd7a6">More...</a><br /></td></tr>
<tr class="separator:a9a3a955fbff1c69e944c3560460dd7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b6a1c5d949f20ad84367fc0f9e1506"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="structflatbuffers_1_1_string.html">String</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#ac0b6a1c5d949f20ad84367fc0f9e1506">CreateString</a> (const <a class="el" href="structflatbuffers_1_1_string.html">String</a> *str)</td></tr>
<tr class="memdesc:ac0b6a1c5d949f20ad84367fc0f9e1506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a string in the buffer, which can contain any binary data.  <a href="#ac0b6a1c5d949f20ad84367fc0f9e1506">More...</a><br /></td></tr>
<tr class="separator:ac0b6a1c5d949f20ad84367fc0f9e1506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77d800e77fa76bc758a6c399fd37685"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab77d800e77fa76bc758a6c399fd37685"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="structflatbuffers_1_1_string.html">String</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#ab77d800e77fa76bc758a6c399fd37685">CreateString</a> (const T &amp;str)</td></tr>
<tr class="memdesc:ab77d800e77fa76bc758a6c399fd37685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a string in the buffer, which can contain any binary data.  <a href="#ab77d800e77fa76bc758a6c399fd37685">More...</a><br /></td></tr>
<tr class="separator:ab77d800e77fa76bc758a6c399fd37685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f51ba9c8f4f24ea2247a3979d095b8"><td class="memTemplParams" colspan="2"><a id="a43f51ba9c8f4f24ea2247a3979d095b8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43f51ba9c8f4f24ea2247a3979d095b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; const T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a43f51ba9c8f4f24ea2247a3979d095b8">CreateStruct</a> (const T &amp;structobj)</td></tr>
<tr class="memdesc:a43f51ba9c8f4f24ea2247a3979d095b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a struct by itself, typically to be part of a union. <br /></td></tr>
<tr class="separator:a43f51ba9c8f4f24ea2247a3979d095b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b96292fa0fb1534fe7fd218a094d0c"><td class="memItemLeft" align="right" valign="top">uoffset_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#ac2b96292fa0fb1534fe7fd218a094d0c">CreateUninitializedVector</a> (size_t len, size_t elemsize, uint8_t **buf)</td></tr>
<tr class="memdesc:ac2b96292fa0fb1534fe7fd218a094d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of <code>CreateVector</code> for non-copying use cases.  <a href="#ac2b96292fa0fb1534fe7fd218a094d0c">More...</a><br /></td></tr>
<tr class="separator:ac2b96292fa0fb1534fe7fd218a094d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2305b63d367845972b51669dd995cc50"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2305b63d367845972b51669dd995cc50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a2305b63d367845972b51669dd995cc50">CreateUninitializedVector</a> (size_t len, T **buf)</td></tr>
<tr class="memdesc:a2305b63d367845972b51669dd995cc50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized version of <code>CreateVector</code> for non-copying use cases.  <a href="#a2305b63d367845972b51669dd995cc50">More...</a><br /></td></tr>
<tr class="separator:a2305b63d367845972b51669dd995cc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9032692fea71e6b61e3f3de499f130"><td class="memTemplParams" colspan="2"><a id="a7f9032692fea71e6b61e3f3de499f130"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7f9032692fea71e6b61e3f3de499f130"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt; const T * &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CreateUninitializedVectorOfStructs</b> (size_t len, T **buf)</td></tr>
<tr class="separator:a7f9032692fea71e6b61e3f3de499f130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cca5c89246a53e80e6ad9487f4c36f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2cca5c89246a53e80e6ad9487f4c36f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a2cca5c89246a53e80e6ad9487f4c36f3">CreateVector</a> (const T *v, size_t len)</td></tr>
<tr class="memdesc:a2cca5c89246a53e80e6ad9487f4c36f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize an array into a FlatBuffer <code>vector</code>.  <a href="#a2cca5c89246a53e80e6ad9487f4c36f3">More...</a><br /></td></tr>
<tr class="separator:a2cca5c89246a53e80e6ad9487f4c36f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44960c5aca0227f960c96a7ed4b881b4"><td class="memTemplParams" colspan="2"><a id="a44960c5aca0227f960c96a7ed4b881b4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a44960c5aca0227f960c96a7ed4b881b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt; <a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CreateVector</b> (const <a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; T &gt; *v, size_t len)</td></tr>
<tr class="separator:a44960c5aca0227f960c96a7ed4b881b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af715dd24dd37cb0151dc7a980ad0f207"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af715dd24dd37cb0151dc7a980ad0f207"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#af715dd24dd37cb0151dc7a980ad0f207">CreateVector</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:af715dd24dd37cb0151dc7a980ad0f207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a <code>std::vector</code> into a FlatBuffer <code>vector</code>.  <a href="#af715dd24dd37cb0151dc7a980ad0f207">More...</a><br /></td></tr>
<tr class="separator:af715dd24dd37cb0151dc7a980ad0f207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274b1afcfa16bab2c884129b2788db19"><td class="memItemLeft" align="right" valign="top"><a id="a274b1afcfa16bab2c884129b2788db19"></a>
<a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt; uint8_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateVector</b> (const std::vector&lt; bool &gt; &amp;v)</td></tr>
<tr class="separator:a274b1afcfa16bab2c884129b2788db19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1080c9e370e2d9d9d872dadd1131436b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1080c9e370e2d9d9d872dadd1131436b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a1080c9e370e2d9d9d872dadd1131436b">CreateVector</a> (size_t vector_size, const std::function&lt; T(size_t i)&gt; &amp;f)</td></tr>
<tr class="memdesc:a1080c9e370e2d9d9d872dadd1131436b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize values returned by a function into a FlatBuffer <code>vector</code>.  <a href="#a1080c9e370e2d9d9d872dadd1131436b">More...</a><br /></td></tr>
<tr class="separator:a1080c9e370e2d9d9d872dadd1131436b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53504fc2cab681a7980b03260f8b2f7a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , typename S &gt; </td></tr>
<tr class="memitem:a53504fc2cab681a7980b03260f8b2f7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a53504fc2cab681a7980b03260f8b2f7a">CreateVector</a> (size_t vector_size, F f, S *state)</td></tr>
<tr class="memdesc:a53504fc2cab681a7980b03260f8b2f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize values returned by a function into a FlatBuffer <code>vector</code>.  <a href="#a53504fc2cab681a7980b03260f8b2f7a">More...</a><br /></td></tr>
<tr class="separator:a53504fc2cab681a7980b03260f8b2f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d57074082aaab8cdeb8474ff9df0b53"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a3d57074082aaab8cdeb8474ff9df0b53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt; const T * &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a3d57074082aaab8cdeb8474ff9df0b53">CreateVectorOfNativeStructs</a> (const S *v, size_t len)</td></tr>
<tr class="memdesc:a3d57074082aaab8cdeb8474ff9df0b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize an array of native structs into a FlatBuffer <code>vector</code>.  <a href="#a3d57074082aaab8cdeb8474ff9df0b53">More...</a><br /></td></tr>
<tr class="separator:a3d57074082aaab8cdeb8474ff9df0b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c291ccd2159604c149600ee6180b95"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a11c291ccd2159604c149600ee6180b95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt; const T * &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a11c291ccd2159604c149600ee6180b95">CreateVectorOfNativeStructs</a> (const std::vector&lt; S &gt; &amp;v)</td></tr>
<tr class="memdesc:a11c291ccd2159604c149600ee6180b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a <code>std::vector</code> of native structs into a FlatBuffer <code>vector</code>.  <a href="#a11c291ccd2159604c149600ee6180b95">More...</a><br /></td></tr>
<tr class="separator:a11c291ccd2159604c149600ee6180b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23aa4c910e053446cc404bc486012e54"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a23aa4c910e053446cc404bc486012e54"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt; const T * &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a23aa4c910e053446cc404bc486012e54">CreateVectorOfSortedNativeStructs</a> (std::vector&lt; S &gt; *v)</td></tr>
<tr class="memdesc:a23aa4c910e053446cc404bc486012e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a <code>std::vector</code> of native structs into a FlatBuffer <code>vector</code> in sorted order.  <a href="#a23aa4c910e053446cc404bc486012e54">More...</a><br /></td></tr>
<tr class="separator:a23aa4c910e053446cc404bc486012e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799701af34c398d8eb86e049b73bcecf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a799701af34c398d8eb86e049b73bcecf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt; const T * &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a799701af34c398d8eb86e049b73bcecf">CreateVectorOfSortedNativeStructs</a> (S *v, size_t len)</td></tr>
<tr class="memdesc:a799701af34c398d8eb86e049b73bcecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize an array of native structs into a FlatBuffer <code>vector</code> in sorted order.  <a href="#a799701af34c398d8eb86e049b73bcecf">More...</a><br /></td></tr>
<tr class="separator:a799701af34c398d8eb86e049b73bcecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc10b709dfa3e72083843d1a5e36c15"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7cc10b709dfa3e72083843d1a5e36c15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt; const T * &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a7cc10b709dfa3e72083843d1a5e36c15">CreateVectorOfSortedStructs</a> (std::vector&lt; T &gt; *v)</td></tr>
<tr class="memdesc:a7cc10b709dfa3e72083843d1a5e36c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a <code>std::vector</code> of structs into a FlatBuffer <code>vector</code> in sorted order.  <a href="#a7cc10b709dfa3e72083843d1a5e36c15">More...</a><br /></td></tr>
<tr class="separator:a7cc10b709dfa3e72083843d1a5e36c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f44cc1b130e13b41e9a80de76e25cf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab1f44cc1b130e13b41e9a80de76e25cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt; const T * &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#ab1f44cc1b130e13b41e9a80de76e25cf">CreateVectorOfSortedStructs</a> (T *v, size_t len)</td></tr>
<tr class="memdesc:ab1f44cc1b130e13b41e9a80de76e25cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize an array of structs into a FlatBuffer <code>vector</code> in sorted order.  <a href="#ab1f44cc1b130e13b41e9a80de76e25cf">More...</a><br /></td></tr>
<tr class="separator:ab1f44cc1b130e13b41e9a80de76e25cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2130ef232ff405eebe2e7f184ecd06e6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2130ef232ff405eebe2e7f184ecd06e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt; <a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a2130ef232ff405eebe2e7f184ecd06e6">CreateVectorOfSortedTables</a> (<a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; T &gt; *v, size_t len)</td></tr>
<tr class="memdesc:a2130ef232ff405eebe2e7f184ecd06e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize an array of <code>table</code> offsets as a <code>vector</code> in the buffer in sorted order.  <a href="#a2130ef232ff405eebe2e7f184ecd06e6">More...</a><br /></td></tr>
<tr class="separator:a2130ef232ff405eebe2e7f184ecd06e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64d11c219559ea51567eab556e13135"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac64d11c219559ea51567eab556e13135"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt; <a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#ac64d11c219559ea51567eab556e13135">CreateVectorOfSortedTables</a> (std::vector&lt; <a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; T &gt;&gt; *v)</td></tr>
<tr class="memdesc:ac64d11c219559ea51567eab556e13135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize an array of <code>table</code> offsets as a <code>vector</code> in the buffer in sorted order.  <a href="#ac64d11c219559ea51567eab556e13135">More...</a><br /></td></tr>
<tr class="separator:ac64d11c219559ea51567eab556e13135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592110519a6c8db1926f1365bf2a58e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt; <a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="structflatbuffers_1_1_string.html">String</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a592110519a6c8db1926f1365bf2a58e6">CreateVectorOfStrings</a> (const std::vector&lt; std::string &gt; &amp;v)</td></tr>
<tr class="memdesc:a592110519a6c8db1926f1365bf2a58e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a <code>std::vector&lt;std::string&gt;</code> into a FlatBuffer <code>vector</code>.  <a href="#a592110519a6c8db1926f1365bf2a58e6">More...</a><br /></td></tr>
<tr class="separator:a592110519a6c8db1926f1365bf2a58e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afede51fd9c32d146cbb1832f57c5e1b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afede51fd9c32d146cbb1832f57c5e1b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt; const T * &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#afede51fd9c32d146cbb1832f57c5e1b7">CreateVectorOfStructs</a> (const T *v, size_t len)</td></tr>
<tr class="memdesc:afede51fd9c32d146cbb1832f57c5e1b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize an array of structs into a FlatBuffer <code>vector</code>.  <a href="#afede51fd9c32d146cbb1832f57c5e1b7">More...</a><br /></td></tr>
<tr class="separator:afede51fd9c32d146cbb1832f57c5e1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e90ada59d9553636f72ce8e4a892f72"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e90ada59d9553636f72ce8e4a892f72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt; const T * &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a6e90ada59d9553636f72ce8e4a892f72">CreateVectorOfStructs</a> (size_t vector_size, const std::function&lt; void(size_t i, T *)&gt; &amp;filler)</td></tr>
<tr class="memdesc:a6e90ada59d9553636f72ce8e4a892f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize an array of structs into a FlatBuffer <code>vector</code>.  <a href="#a6e90ada59d9553636f72ce8e4a892f72">More...</a><br /></td></tr>
<tr class="separator:a6e90ada59d9553636f72ce8e4a892f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc09fa59ff9732e972877cfe911c8a5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , typename S &gt; </td></tr>
<tr class="memitem:a9cc09fa59ff9732e972877cfe911c8a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt; const T * &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a9cc09fa59ff9732e972877cfe911c8a5">CreateVectorOfStructs</a> (size_t vector_size, F f, S *state)</td></tr>
<tr class="memdesc:a9cc09fa59ff9732e972877cfe911c8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize an array of structs into a FlatBuffer <code>vector</code>.  <a href="#a9cc09fa59ff9732e972877cfe911c8a5">More...</a><br /></td></tr>
<tr class="separator:a9cc09fa59ff9732e972877cfe911c8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110c2a3298aebef1a9dfa3c44ee84f42"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Alloc &gt; </td></tr>
<tr class="memitem:a110c2a3298aebef1a9dfa3c44ee84f42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt; const T * &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a110c2a3298aebef1a9dfa3c44ee84f42">CreateVectorOfStructs</a> (const std::vector&lt; T, Alloc &gt; &amp;v)</td></tr>
<tr class="memdesc:a110c2a3298aebef1a9dfa3c44ee84f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a <code>std::vector</code> of structs into a FlatBuffer <code>vector</code>.  <a href="#a110c2a3298aebef1a9dfa3c44ee84f42">More...</a><br /></td></tr>
<tr class="separator:a110c2a3298aebef1a9dfa3c44ee84f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa905b29dce19a1795c7bce375cf29961"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#aa905b29dce19a1795c7bce375cf29961">DedupVtables</a> (bool dedup)</td></tr>
<tr class="memdesc:aa905b29dce19a1795c7bce375cf29961"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default vtables are deduped in order to save space.  <a href="#aa905b29dce19a1795c7bce375cf29961">More...</a><br /></td></tr>
<tr class="separator:aa905b29dce19a1795c7bce375cf29961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9e507b373d598b51052fab4fa34912"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0c9e507b373d598b51052fab4fa34912"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a0c9e507b373d598b51052fab4fa34912">Finish</a> (<a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; T &gt; root, const char *file_identifier=nullptr)</td></tr>
<tr class="memdesc:a0c9e507b373d598b51052fab4fa34912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish serializing a buffer by writing the root offset.  <a href="#a0c9e507b373d598b51052fab4fa34912">More...</a><br /></td></tr>
<tr class="separator:a0c9e507b373d598b51052fab4fa34912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba8462e408431054c99d25120326220"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ba8462e408431054c99d25120326220"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a7ba8462e408431054c99d25120326220">FinishSizePrefixed</a> (<a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; T &gt; root, const char *file_identifier=nullptr)</td></tr>
<tr class="memdesc:a7ba8462e408431054c99d25120326220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish a buffer with a 32 bit size field pre-fixed (size of the buffer following the size field).  <a href="#a7ba8462e408431054c99d25120326220">More...</a><br /></td></tr>
<tr class="separator:a7ba8462e408431054c99d25120326220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0173786ea4ec3e4ae10555639b2996c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#ab0173786ea4ec3e4ae10555639b2996c">FlatBufferBuilder</a> (size_t initial_size=1024, <a class="el" href="classflatbuffers_1_1_allocator.html">Allocator</a> *allocator=nullptr, bool own_allocator=false, size_t buffer_minalign=AlignOf&lt; largest_scalar_t &gt;())</td></tr>
<tr class="memdesc:ab0173786ea4ec3e4ae10555639b2996c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for FlatBufferBuilder.  <a href="#ab0173786ea4ec3e4ae10555639b2996c">More...</a><br /></td></tr>
<tr class="separator:ab0173786ea4ec3e4ae10555639b2996c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e1a348b7474fd5d239016ae97afc56"><td class="memItemLeft" align="right" valign="top"><a id="a86e1a348b7474fd5d239016ae97afc56"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a86e1a348b7474fd5d239016ae97afc56">FlatBufferBuilder</a> (<a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html">FlatBufferBuilder</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a86e1a348b7474fd5d239016ae97afc56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor for FlatBufferBuilder. <br /></td></tr>
<tr class="separator:a86e1a348b7474fd5d239016ae97afc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a8fd46b34ad7727406c37b65b6b27a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a16a8fd46b34ad7727406c37b65b6b27a">ForceDefaults</a> (bool fd)</td></tr>
<tr class="memdesc:a16a8fd46b34ad7727406c37b65b6b27a"><td class="mdescLeft">&#160;</td><td class="mdescRight">In order to save space, fields that are set to their default value don't get serialized into the buffer.  <a href="#a16a8fd46b34ad7727406c37b65b6b27a">More...</a><br /></td></tr>
<tr class="separator:a16a8fd46b34ad7727406c37b65b6b27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ebce1f3f46832946a95952af1e9c2b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#aa1ebce1f3f46832946a95952af1e9c2b">GetBufferMinAlignment</a> ()</td></tr>
<tr class="memdesc:aa1ebce1f3f46832946a95952af1e9c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the minimum alignment this buffer needs to be accessed properly.  <a href="#aa1ebce1f3f46832946a95952af1e9c2b">More...</a><br /></td></tr>
<tr class="separator:aa1ebce1f3f46832946a95952af1e9c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81ab8aa273c270b0942fd81489cad83"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#ab81ab8aa273c270b0942fd81489cad83">GetBufferPointer</a> () const</td></tr>
<tr class="memdesc:ab81ab8aa273c270b0942fd81489cad83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the serialized buffer (after you call <code>Finish()</code>).  <a href="#ab81ab8aa273c270b0942fd81489cad83">More...</a><br /></td></tr>
<tr class="separator:ab81ab8aa273c270b0942fd81489cad83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099810f03046139d1854d20a1c2a2e41"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a099810f03046139d1854d20a1c2a2e41">GetCurrentBufferPointer</a> () const</td></tr>
<tr class="memdesc:a099810f03046139d1854d20a1c2a2e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to an unfinished buffer.  <a href="#a099810f03046139d1854d20a1c2a2e41">More...</a><br /></td></tr>
<tr class="separator:a099810f03046139d1854d20a1c2a2e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c8fd33ab9b3b237954c9ea38648f7f"><td class="memItemLeft" align="right" valign="top">uoffset_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a66c8fd33ab9b3b237954c9ea38648f7f">GetSize</a> () const</td></tr>
<tr class="memdesc:a66c8fd33ab9b3b237954c9ea38648f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current size of the serialized buffer, counting from the end.  <a href="#a66c8fd33ab9b3b237954c9ea38648f7f">More...</a><br /></td></tr>
<tr class="separator:a66c8fd33ab9b3b237954c9ea38648f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65f0619ecb7715ffdae399ebfc56e38"><td class="memItemLeft" align="right" valign="top"><a id="ae65f0619ecb7715ffdae399ebfc56e38"></a>
<a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html">FlatBufferBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#ae65f0619ecb7715ffdae399ebfc56e38">operator=</a> (<a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html">FlatBufferBuilder</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:ae65f0619ecb7715ffdae399ebfc56e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator for FlatBufferBuilder. <br /></td></tr>
<tr class="separator:ae65f0619ecb7715ffdae399ebfc56e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2c3a1e47f0ab4a3a3f07a07a52fb45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflatbuffers_1_1_detached_buffer.html">DetachedBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a5e2c3a1e47f0ab4a3a3f07a07a52fb45">Release</a> ()</td></tr>
<tr class="memdesc:a5e2c3a1e47f0ab4a3a3f07a07a52fb45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the released DetachedBuffer.  <a href="#a5e2c3a1e47f0ab4a3a3f07a07a52fb45">More...</a><br /></td></tr>
<tr class="separator:a5e2c3a1e47f0ab4a3a3f07a07a52fb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e715d9019060b4b753c4e5228be56e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflatbuffers_1_1_detached_buffer.html">DetachedBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#a0e715d9019060b4b753c4e5228be56e8">ReleaseBufferPointer</a> ()</td></tr>
<tr class="memdesc:a0e715d9019060b4b753c4e5228be56e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the released pointer to the serialized buffer.  <a href="#a0e715d9019060b4b753c4e5228be56e8">More...</a><br /></td></tr>
<tr class="separator:a0e715d9019060b4b753c4e5228be56e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa090a68856f7b554cc7cac3c279fb416"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#aa090a68856f7b554cc7cac3c279fb416">ReleaseRaw</a> (size_t &amp;size, size_t &amp;offset)</td></tr>
<tr class="memdesc:aa090a68856f7b554cc7cac3c279fb416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the released pointer to the serialized buffer.  <a href="#aa090a68856f7b554cc7cac3c279fb416">More...</a><br /></td></tr>
<tr class="separator:aa090a68856f7b554cc7cac3c279fb416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952495120d5c56d600640091334b5341"><td class="memItemLeft" align="right" valign="top"><a id="a952495120d5c56d600640091334b5341"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Reset</b> ()</td></tr>
<tr class="separator:a952495120d5c56d600640091334b5341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f39e7a4d9b0b32a805c77bffed245a"><td class="memItemLeft" align="right" valign="top"><a id="a59f39e7a4d9b0b32a805c77bffed245a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Swap</b> (<a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html">FlatBufferBuilder</a> &amp;other)</td></tr>
<tr class="separator:a59f39e7a4d9b0b32a805c77bffed245a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af8c7583c92e1d1d6f438977da5158d19"><td class="memItemLeft" align="right" valign="top"><a id="af8c7583c92e1d1d6f438977da5158d19"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html#af8c7583c92e1d1d6f438977da5158d19">kFileIdentifierLength</a> = 4</td></tr>
<tr class="memdesc:af8c7583c92e1d1d6f438977da5158d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">The length of a FlatBuffer file header. <br /></td></tr>
<tr class="separator:af8c7583c92e1d1d6f438977da5158d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a9190cb2d5a4324ab0c52263b834fff09"><td class="memItemLeft" align="right" valign="top"><a id="a9190cb2d5a4324ab0c52263b834fff09"></a>
typedef std::set&lt; <a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; <a class="el" href="structflatbuffers_1_1_string.html">String</a> &gt;, <a class="el" href="structflatbuffers_1_1_flat_buffer_builder_1_1_string_offset_compare.html">StringOffsetCompare</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>StringOffsetMap</b></td></tr>
<tr class="separator:a9190cb2d5a4324ab0c52263b834fff09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2e4de5642bad6dcd01eb7e7eaf719c89"><td class="memItemLeft" align="right" valign="top"><a id="a2e4de5642bad6dcd01eb7e7eaf719c89"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Finish</b> (uoffset_t root, const char *file_identifier, bool size_prefix)</td></tr>
<tr class="separator:a2e4de5642bad6dcd01eb7e7eaf719c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4606286a25d3fedfb1532934d4cea1"><td class="memItemLeft" align="right" valign="top"><a id="ace4606286a25d3fedfb1532934d4cea1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FlatBufferBuilder</b> (const <a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html">FlatBufferBuilder</a> &amp;)</td></tr>
<tr class="separator:ace4606286a25d3fedfb1532934d4cea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376bb6858e8b1baab9a437f3f9f0b334"><td class="memItemLeft" align="right" valign="top"><a id="a376bb6858e8b1baab9a437f3f9f0b334"></a>
<a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html">FlatBufferBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classflatbuffers_1_1_flat_buffer_builder.html">FlatBufferBuilder</a> &amp;)</td></tr>
<tr class="separator:a376bb6858e8b1baab9a437f3f9f0b334"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9a3886be63710d8bb88f2ade4ac8420d"><td class="memItemLeft" align="right" valign="top"><a id="a9a3886be63710d8bb88f2ade4ac8420d"></a>
<a class="el" href="classflatbuffers_1_1vector__downward.html">vector_downward</a>&#160;</td><td class="memItemRight" valign="bottom"><b>buf_</b></td></tr>
<tr class="separator:a9a3886be63710d8bb88f2ade4ac8420d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b31b32fb478a9ec68164e1579c7ebe7"><td class="memItemLeft" align="right" valign="top"><a id="a6b31b32fb478a9ec68164e1579c7ebe7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>dedup_vtables_</b></td></tr>
<tr class="separator:a6b31b32fb478a9ec68164e1579c7ebe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2cc618aeb6f6c411c7ab734649e1a81"><td class="memItemLeft" align="right" valign="top"><a id="ab2cc618aeb6f6c411c7ab734649e1a81"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>finished</b></td></tr>
<tr class="separator:ab2cc618aeb6f6c411c7ab734649e1a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c2d7c686a2df8014cb453ec70fdccd"><td class="memItemLeft" align="right" valign="top"><a id="a89c2d7c686a2df8014cb453ec70fdccd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>force_defaults_</b></td></tr>
<tr class="separator:a89c2d7c686a2df8014cb453ec70fdccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e604e3caf95fd0f0e74545af5a8420a"><td class="memItemLeft" align="right" valign="top"><a id="a5e604e3caf95fd0f0e74545af5a8420a"></a>
voffset_t&#160;</td><td class="memItemRight" valign="bottom"><b>max_voffset_</b></td></tr>
<tr class="separator:a5e604e3caf95fd0f0e74545af5a8420a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9942e76ff29eefc702b006b19ce02ba"><td class="memItemLeft" align="right" valign="top"><a id="ab9942e76ff29eefc702b006b19ce02ba"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>minalign_</b></td></tr>
<tr class="separator:ab9942e76ff29eefc702b006b19ce02ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6d502accf426e35f91f2539baff6b2"><td class="memItemLeft" align="right" valign="top"><a id="add6d502accf426e35f91f2539baff6b2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>nested</b></td></tr>
<tr class="separator:add6d502accf426e35f91f2539baff6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb473c5fd1305213b91eecaa779ecafa"><td class="memItemLeft" align="right" valign="top"><a id="adb473c5fd1305213b91eecaa779ecafa"></a>
uoffset_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_field_loc</b></td></tr>
<tr class="separator:adb473c5fd1305213b91eecaa779ecafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e64b654cef62869c3dfd27def92e5d"><td class="memItemLeft" align="right" valign="top"><a id="aa7e64b654cef62869c3dfd27def92e5d"></a>
StringOffsetMap *&#160;</td><td class="memItemRight" valign="bottom"><b>string_pool</b></td></tr>
<tr class="separator:aa7e64b654cef62869c3dfd27def92e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab0173786ea4ec3e4ae10555639b2996c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0173786ea4ec3e4ae10555639b2996c">&#9670;&nbsp;</a></span>FlatBufferBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flatbuffers::FlatBufferBuilder::FlatBufferBuilder </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>initial_size</em> = <code>1024</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflatbuffers_1_1_allocator.html">Allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own_allocator</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_minalign</em> = <code>AlignOf&lt;largest_scalar_t&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor for FlatBufferBuilder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">initial_size</td><td>The initial size of the buffer, in bytes. Defaults to <code>1024</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>An <code>Allocator</code> to use. If null will use <code>DefaultAllocator</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">own_allocator</td><td>Whether the builder/vector should own the allocator. Defaults to / <code>false</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_minalign</td><td>Force the buffer to be aligned to the given minimum alignment upon reallocation. Only needed if you intend to store types with custom alignment AND you wish to read the buffer in-place directly after creation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae94b94ba71ea0aeb2d9a98c43b713412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94b94ba71ea0aeb2d9a98c43b713412">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flatbuffers::FlatBufferBuilder::Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset all the state in this FlatBufferBuilder so it can be reused to construct another buffer. </p>

</div>
</div>
<a id="ab478a645216d2d613fc7b7c29b0ff9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab478a645216d2d613fc7b7c29b0ff9d1">&#9670;&nbsp;</a></span>CreateSharedString() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="structflatbuffers_1_1_string.html">String</a>&gt; flatbuffers::FlatBufferBuilder::CreateSharedString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store a string in the buffer, which can contain any binary data. </p>
<p>If a string with this exact contents has already been serialized before, instead simply returns the offset of the existing string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>A const char pointer to the data to be stored as a string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of bytes that should be stored from <code>str</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the offset in the buffer where the string starts. </dd></dl>

</div>
</div>
<a id="a3eb68613e5883dc4b8fff6cf7d1223d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb68613e5883dc4b8fff6cf7d1223d7">&#9670;&nbsp;</a></span>CreateSharedString() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="structflatbuffers_1_1_string.html">String</a>&gt; flatbuffers::FlatBufferBuilder::CreateSharedString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store a string in the buffer, which null-terminated. </p>
<p>If a string with this exact contents has already been serialized before, instead simply returns the offset of the existing string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>A const char pointer to a C-string to add to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the offset in the buffer where the string starts. </dd></dl>

</div>
</div>
<a id="a10e8ec7d1c8fbdc21b1c7047bbbe38d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10e8ec7d1c8fbdc21b1c7047bbbe38d9">&#9670;&nbsp;</a></span>CreateSharedString() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="structflatbuffers_1_1_string.html">String</a>&gt; flatbuffers::FlatBufferBuilder::CreateSharedString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store a string in the buffer, which can contain any binary data. </p>
<p>If a string with this exact contents has already been serialized before, instead simply returns the offset of the existing string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>A const reference to a std::string to store in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the offset in the buffer where the string starts. </dd></dl>

</div>
</div>
<a id="a840b769fbb4148f97d3eed266e4690c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840b769fbb4148f97d3eed266e4690c3">&#9670;&nbsp;</a></span>CreateSharedString() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="structflatbuffers_1_1_string.html">String</a>&gt; flatbuffers::FlatBufferBuilder::CreateSharedString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflatbuffers_1_1_string.html">String</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store a string in the buffer, which can contain any binary data. </p>
<p>If a string with this exact contents has already been serialized before, instead simply returns the offset of the existing string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>A const pointer to a <code>String</code> struct to add to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the offset in the buffer where the string starts </dd></dl>

</div>
</div>
<a id="aec6f9df2a0366b540b24822414d92cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6f9df2a0366b540b24822414d92cbe">&#9670;&nbsp;</a></span>CreateString() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="structflatbuffers_1_1_string.html">String</a>&gt; flatbuffers::FlatBufferBuilder::CreateString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store a string in the buffer, which can contain any binary data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>A const char pointer to the data to be stored as a string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of bytes that should be stored from <code>str</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the offset in the buffer where the string starts. </dd></dl>

</div>
</div>
<a id="aad93d113ac24e86ed04b5236b3f4c0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad93d113ac24e86ed04b5236b3f4c0c5">&#9670;&nbsp;</a></span>CreateString() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="structflatbuffers_1_1_string.html">String</a>&gt; flatbuffers::FlatBufferBuilder::CreateString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store a string in the buffer, which is null-terminated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>A const char pointer to a C-string to add to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the offset in the buffer where the string starts. </dd></dl>

</div>
</div>
<a id="ac51db9083ac815eb81420b6d51f42154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51db9083ac815eb81420b6d51f42154">&#9670;&nbsp;</a></span>CreateString() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="structflatbuffers_1_1_string.html">String</a>&gt; flatbuffers::FlatBufferBuilder::CreateString </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store a string in the buffer, which is null-terminated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>A char pointer to a C-string to add to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the offset in the buffer where the string starts. </dd></dl>

</div>
</div>
<a id="a8c3af55e64f5cda9aefa38ac5287ef9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3af55e64f5cda9aefa38ac5287ef9f">&#9670;&nbsp;</a></span>CreateString() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="structflatbuffers_1_1_string.html">String</a>&gt; flatbuffers::FlatBufferBuilder::CreateString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store a string in the buffer, which can contain any binary data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>A const reference to a std::string to store in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the offset in the buffer where the string starts. </dd></dl>

</div>
</div>
<a id="a9a3a955fbff1c69e944c3560460dd7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3a955fbff1c69e944c3560460dd7a6">&#9670;&nbsp;</a></span>CreateString() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="structflatbuffers_1_1_string.html">String</a>&gt; flatbuffers::FlatBufferBuilder::CreateString </td>
          <td>(</td>
          <td class="paramtype">flatbuffers::string_view&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store a string in the buffer, which can contain any binary data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>A const string_view to copy in to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the offset in the buffer where the string starts. </dd></dl>

</div>
</div>
<a id="ac0b6a1c5d949f20ad84367fc0f9e1506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b6a1c5d949f20ad84367fc0f9e1506">&#9670;&nbsp;</a></span>CreateString() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="structflatbuffers_1_1_string.html">String</a>&gt; flatbuffers::FlatBufferBuilder::CreateString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflatbuffers_1_1_string.html">String</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store a string in the buffer, which can contain any binary data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>A const pointer to a <code>String</code> struct to add to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the offset in the buffer where the string starts </dd></dl>

</div>
</div>
<a id="ab77d800e77fa76bc758a6c399fd37685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77d800e77fa76bc758a6c399fd37685">&#9670;&nbsp;</a></span>CreateString() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="structflatbuffers_1_1_string.html">String</a>&gt; flatbuffers::FlatBufferBuilder::CreateString </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store a string in the buffer, which can contain any binary data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>A const reference to a std::string like type with support of T::c_str() and T::length() to store in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the offset in the buffer where the string starts. </dd></dl>

</div>
</div>
<a id="ac2b96292fa0fb1534fe7fd218a094d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b96292fa0fb1534fe7fd218a094d0c">&#9670;&nbsp;</a></span>CreateUninitializedVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uoffset_t flatbuffers::FlatBufferBuilder::CreateUninitializedVector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elemsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialized version of <code>CreateVector</code> for non-copying use cases. </p>
<p>Write the data any time later to the returned buffer pointer <code>buf</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of elements to store in the <code>vector</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elemsize</td><td>The size of each element in the <code>vector</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>A pointer to a <code>uint8_t</code> pointer that can be written to at a later time to serialize the data into a <code>vector</code> in the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2305b63d367845972b51669dd995cc50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2305b63d367845972b51669dd995cc50">&#9670;&nbsp;</a></span>CreateUninitializedVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt;T&gt; &gt; flatbuffers::FlatBufferBuilder::CreateUninitializedVector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T **&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialized version of <code>CreateVector</code> for non-copying use cases. </p>
<p>Write the data any time later to the returned buffer pointer <code>buf</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type of the data that will be stored in the buffer as a <code>vector</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of elements to store in the <code>vector</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>A pointer to a pointer of type <code>T</code> that can be written to at a later time to serialize the data into a <code>vector</code> in the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cca5c89246a53e80e6ad9487f4c36f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cca5c89246a53e80e6ad9487f4c36f3">&#9670;&nbsp;</a></span>CreateVector() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt;T&gt; &gt; flatbuffers::FlatBufferBuilder::CreateVector </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize an array into a FlatBuffer <code>vector</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type of the array elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>A pointer to the array of type <code>T</code> to serialize into the buffer as a <code>vector</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of elements to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a typed <code>Offset</code> into the serialized data indicating where the vector is stored. </dd></dl>

</div>
</div>
<a id="af715dd24dd37cb0151dc7a980ad0f207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af715dd24dd37cb0151dc7a980ad0f207">&#9670;&nbsp;</a></span>CreateVector() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt;T&gt; &gt; flatbuffers::FlatBufferBuilder::CreateVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize a <code>std::vector</code> into a FlatBuffer <code>vector</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type of the <code>std::vector</code> elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A const reference to the <code>std::vector</code> to serialize into the buffer as a <code>vector</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a typed <code>Offset</code> into the serialized data indicating where the vector is stored. </dd></dl>

</div>
</div>
<a id="a1080c9e370e2d9d9d872dadd1131436b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1080c9e370e2d9d9d872dadd1131436b">&#9670;&nbsp;</a></span>CreateVector() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt;T&gt; &gt; flatbuffers::FlatBufferBuilder::CreateVector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vector_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; T(size_t i)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize values returned by a function into a FlatBuffer <code>vector</code>. </p>
<p>This is a convenience function that takes care of iteration for you. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type of the <code>std::vector</code> elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function that takes the current iteration 0..vector_size-1 and returns any type that you can construct a FlatBuffers vector out of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a typed <code>Offset</code> into the serialized data indicating where the vector is stored. </dd></dl>

</div>
</div>
<a id="a53504fc2cab681a7980b03260f8b2f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53504fc2cab681a7980b03260f8b2f7a">&#9670;&nbsp;</a></span>CreateVector() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt;T&gt; &gt; flatbuffers::FlatBufferBuilder::CreateVector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vector_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize values returned by a function into a FlatBuffer <code>vector</code>. </p>
<p>This is a convenience function that takes care of iteration for you. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type of the <code>std::vector</code> elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function that takes the current iteration 0..vector_size-1, and the state parameter returning any type that you can construct a FlatBuffers vector out of. </td></tr>
    <tr><td class="paramname">state</td><td>State passed to f. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a typed <code>Offset</code> into the serialized data indicating where the vector is stored. </dd></dl>

</div>
</div>
<a id="a3d57074082aaab8cdeb8474ff9df0b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d57074082aaab8cdeb8474ff9df0b53">&#9670;&nbsp;</a></span>CreateVectorOfNativeStructs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt;const T *&gt; &gt; flatbuffers::FlatBufferBuilder::CreateVectorOfNativeStructs </td>
          <td>(</td>
          <td class="paramtype">const S *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize an array of native structs into a FlatBuffer <code>vector</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type of the struct array elements. </td></tr>
    <tr><td class="paramname">S</td><td>The data type of the native struct array elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>A pointer to the array of type <code>S</code> to serialize into the buffer as a <code>vector</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of elements to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a typed <code>Offset</code> into the serialized data indicating where the vector is stored. </dd></dl>

</div>
</div>
<a id="a11c291ccd2159604c149600ee6180b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c291ccd2159604c149600ee6180b95">&#9670;&nbsp;</a></span>CreateVectorOfNativeStructs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt;const T *&gt; &gt; flatbuffers::FlatBufferBuilder::CreateVectorOfNativeStructs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; S &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize a <code>std::vector</code> of native structs into a FlatBuffer <code>vector</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type of the <code>std::vector</code> struct elements. </td></tr>
    <tr><td class="paramname">S</td><td>The data type of the <code>std::vector</code> native struct elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23aa4c910e053446cc404bc486012e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23aa4c910e053446cc404bc486012e54">&#9670;&nbsp;</a></span>CreateVectorOfSortedNativeStructs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt;const T *&gt; &gt; flatbuffers::FlatBufferBuilder::CreateVectorOfSortedNativeStructs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; S &gt; *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize a <code>std::vector</code> of native structs into a FlatBuffer <code>vector</code> in sorted order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type of the <code>std::vector</code> struct elements. </td></tr>
    <tr><td class="paramname">S</td><td>The data type of the <code>std::vector</code> native struct elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a799701af34c398d8eb86e049b73bcecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a799701af34c398d8eb86e049b73bcecf">&#9670;&nbsp;</a></span>CreateVectorOfSortedNativeStructs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt;const T *&gt; &gt; flatbuffers::FlatBufferBuilder::CreateVectorOfSortedNativeStructs </td>
          <td>(</td>
          <td class="paramtype">S *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize an array of native structs into a FlatBuffer <code>vector</code> in sorted order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type of the struct array elements. </td></tr>
    <tr><td class="paramname">S</td><td>The data type of the native struct array elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>A pointer to the array of type <code>S</code> to serialize into the buffer as a <code>vector</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of elements to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a typed <code>Offset</code> into the serialized data indicating where the vector is stored. </dd></dl>

</div>
</div>
<a id="a7cc10b709dfa3e72083843d1a5e36c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc10b709dfa3e72083843d1a5e36c15">&#9670;&nbsp;</a></span>CreateVectorOfSortedStructs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt;const T *&gt; &gt; flatbuffers::FlatBufferBuilder::CreateVectorOfSortedStructs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize a <code>std::vector</code> of structs into a FlatBuffer <code>vector</code> in sorted order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type of the <code>std::vector</code> struct elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1f44cc1b130e13b41e9a80de76e25cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f44cc1b130e13b41e9a80de76e25cf">&#9670;&nbsp;</a></span>CreateVectorOfSortedStructs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt;const T *&gt; &gt; flatbuffers::FlatBufferBuilder::CreateVectorOfSortedStructs </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize an array of structs into a FlatBuffer <code>vector</code> in sorted order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type of the struct array elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>A pointer to the array of type <code>T</code> to serialize into the buffer as a <code>vector</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of elements to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a typed <code>Offset</code> into the serialized data indicating where the vector is stored. </dd></dl>

</div>
</div>
<a id="a2130ef232ff405eebe2e7f184ecd06e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2130ef232ff405eebe2e7f184ecd06e6">&#9670;&nbsp;</a></span>CreateVectorOfSortedTables() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt;<a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;T&gt; &gt; &gt; flatbuffers::FlatBufferBuilder::CreateVectorOfSortedTables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize an array of <code>table</code> offsets as a <code>vector</code> in the buffer in sorted order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type that the offset refers to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>An array of type <code>Offset&lt;T&gt;</code> that contains the <code>table</code> offsets to store in the buffer in sorted order. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of elements to store in the <code>vector</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a typed <code>Offset</code> into the serialized data indicating where the vector is stored. </dd></dl>

</div>
</div>
<a id="ac64d11c219559ea51567eab556e13135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64d11c219559ea51567eab556e13135">&#9670;&nbsp;</a></span>CreateVectorOfSortedTables() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt;<a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;T&gt; &gt; &gt; flatbuffers::FlatBufferBuilder::CreateVectorOfSortedTables </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; T &gt;&gt; *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize an array of <code>table</code> offsets as a <code>vector</code> in the buffer in sorted order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type that the offset refers to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>An array of type <code>Offset&lt;T&gt;</code> that contains the <code>table</code> offsets to store in the buffer in sorted order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a typed <code>Offset</code> into the serialized data indicating where the vector is stored. </dd></dl>

</div>
</div>
<a id="a592110519a6c8db1926f1365bf2a58e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592110519a6c8db1926f1365bf2a58e6">&#9670;&nbsp;</a></span>CreateVectorOfStrings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt;<a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="structflatbuffers_1_1_string.html">String</a>&gt; &gt; &gt; flatbuffers::FlatBufferBuilder::CreateVectorOfStrings </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize a <code>std::vector&lt;std::string&gt;</code> into a FlatBuffer <code>vector</code>. </p>
<p>This is a convenience function for a common case. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A const reference to the <code>std::vector</code> to serialize into the buffer as a <code>vector</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a typed <code>Offset</code> into the serialized data indicating where the vector is stored. </dd></dl>

</div>
</div>
<a id="afede51fd9c32d146cbb1832f57c5e1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afede51fd9c32d146cbb1832f57c5e1b7">&#9670;&nbsp;</a></span>CreateVectorOfStructs() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt;const T *&gt; &gt; flatbuffers::FlatBufferBuilder::CreateVectorOfStructs </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize an array of structs into a FlatBuffer <code>vector</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type of the struct array elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>A pointer to the array of type <code>T</code> to serialize into the buffer as a <code>vector</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of elements to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a typed <code>Offset</code> into the serialized data indicating where the vector is stored. </dd></dl>

</div>
</div>
<a id="a6e90ada59d9553636f72ce8e4a892f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e90ada59d9553636f72ce8e4a892f72">&#9670;&nbsp;</a></span>CreateVectorOfStructs() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt;const T *&gt; &gt; flatbuffers::FlatBufferBuilder::CreateVectorOfStructs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vector_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(size_t i, T *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>filler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize an array of structs into a FlatBuffer <code>vector</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type of the struct array elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>A function that takes the current iteration 0..vector_size-1 and a pointer to the struct that must be filled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a typed <code>Offset</code> into the serialized data indicating where the vector is stored. This is mostly useful when flatbuffers are generated with mutation accessors. </dd></dl>

</div>
</div>
<a id="a9cc09fa59ff9732e972877cfe911c8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc09fa59ff9732e972877cfe911c8a5">&#9670;&nbsp;</a></span>CreateVectorOfStructs() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt;const T *&gt; &gt; flatbuffers::FlatBufferBuilder::CreateVectorOfStructs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vector_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize an array of structs into a FlatBuffer <code>vector</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type of the struct array elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>A function that takes the current iteration 0..vector_size-1, a pointer to the struct that must be filled and the state argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Arbitrary state to pass to f. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a typed <code>Offset</code> into the serialized data indicating where the vector is stored. This is mostly useful when flatbuffers are generated with mutation accessors. </dd></dl>

</div>
</div>
<a id="a110c2a3298aebef1a9dfa3c44ee84f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110c2a3298aebef1a9dfa3c44ee84f42">&#9670;&nbsp;</a></span>CreateVectorOfStructs() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt;<a class="el" href="classflatbuffers_1_1_vector.html">Vector</a>&lt;const T *&gt; &gt; flatbuffers::FlatBufferBuilder::CreateVectorOfStructs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize a <code>std::vector</code> of structs into a FlatBuffer <code>vector</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type of the <code>std::vector</code> struct elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa905b29dce19a1795c7bce375cf29961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa905b29dce19a1795c7bce375cf29961">&#9670;&nbsp;</a></span>DedupVtables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flatbuffers::FlatBufferBuilder::DedupVtables </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dedup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>By default vtables are deduped in order to save space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bool</td><td>dedup When set to <code>true</code>, dedup vtables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c9e507b373d598b51052fab4fa34912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9e507b373d598b51052fab4fa34912">&#9670;&nbsp;</a></span>Finish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flatbuffers::FlatBufferBuilder::Finish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_identifier</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish serializing a buffer by writing the root offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_identifier</td><td>If a <code>file_identifier</code> is given, the buffer will be prefixed with a standard FlatBuffers file header. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ba8462e408431054c99d25120326220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba8462e408431054c99d25120326220">&#9670;&nbsp;</a></span>FinishSizePrefixed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flatbuffers::FlatBufferBuilder::FinishSizePrefixed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structflatbuffers_1_1_offset.html">Offset</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_identifier</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish a buffer with a 32 bit size field pre-fixed (size of the buffer following the size field). </p>
<p>These buffers are NOT compatible with standard buffers created by Finish, i.e. you can't call GetRoot on them, you have to use GetSizePrefixedRoot instead. All &gt;32 bit quantities in this buffer will be aligned when the whole size pre-fixed buffer is aligned. These kinds of buffers are useful for creating a stream of FlatBuffers. </p>

</div>
</div>
<a id="a16a8fd46b34ad7727406c37b65b6b27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a8fd46b34ad7727406c37b65b6b27a">&#9670;&nbsp;</a></span>ForceDefaults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flatbuffers::FlatBufferBuilder::ForceDefaults </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In order to save space, fields that are set to their default value don't get serialized into the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bool</td><td>fd When set to <code>true</code>, always serializes default values that are set. Optional fields which are not set explicitly, will still not be serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1ebce1f3f46832946a95952af1e9c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ebce1f3f46832946a95952af1e9c2b">&#9670;&nbsp;</a></span>GetBufferMinAlignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t flatbuffers::FlatBufferBuilder::GetBufferMinAlignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the minimum alignment this buffer needs to be accessed properly. </p>
<p>This is only known once all elements have been written (after you call Finish()). You can use this information if you need to embed a FlatBuffer in some other buffer, such that you can later read it without first having to copy it into its own buffer. </p>

</div>
</div>
<a id="ab81ab8aa273c270b0942fd81489cad83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81ab8aa273c270b0942fd81489cad83">&#9670;&nbsp;</a></span>GetBufferPointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* flatbuffers::FlatBufferBuilder::GetBufferPointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the serialized buffer (after you call <code>Finish()</code>). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns an <code>uint8_t</code> pointer to the FlatBuffer data inside the buffer. </dd></dl>

</div>
</div>
<a id="a099810f03046139d1854d20a1c2a2e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099810f03046139d1854d20a1c2a2e41">&#9670;&nbsp;</a></span>GetCurrentBufferPointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* flatbuffers::FlatBufferBuilder::GetCurrentBufferPointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to an unfinished buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code>uint8_t</code> pointer to the unfinished buffer. </dd></dl>

</div>
</div>
<a id="a66c8fd33ab9b3b237954c9ea38648f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c8fd33ab9b3b237954c9ea38648f7f">&#9670;&nbsp;</a></span>GetSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uoffset_t flatbuffers::FlatBufferBuilder::GetSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current size of the serialized buffer, counting from the end. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns an <code>uoffset_t</code> with the current size of the buffer. </dd></dl>

</div>
</div>
<a id="a5e2c3a1e47f0ab4a3a3f07a07a52fb45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2c3a1e47f0ab4a3a3f07a07a52fb45">&#9670;&nbsp;</a></span>Release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflatbuffers_1_1_detached_buffer.html">DetachedBuffer</a> flatbuffers::FlatBufferBuilder::Release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the released DetachedBuffer. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>DetachedBuffer</code> that owns the buffer and its allocator. </dd></dl>

</div>
</div>
<a id="a0e715d9019060b4b753c4e5228be56e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e715d9019060b4b753c4e5228be56e8">&#9670;&nbsp;</a></span>ReleaseBufferPointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflatbuffers_1_1_detached_buffer.html">DetachedBuffer</a> flatbuffers::FlatBufferBuilder::ReleaseBufferPointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the released pointer to the serialized buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>Do NOT attempt to use this FlatBufferBuilder afterwards! </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>FlatBuffer</code> that owns the buffer and its allocator and behaves similar to a <code>unique_ptr</code> with a deleter. Deprecated: use Release() instead </dd></dl>

</div>
</div>
<a id="aa090a68856f7b554cc7cac3c279fb416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa090a68856f7b554cc7cac3c279fb416">&#9670;&nbsp;</a></span>ReleaseRaw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* flatbuffers::FlatBufferBuilder::ReleaseRaw </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the released pointer to the serialized buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>size of the memory block containing the serialized <code>FlatBuffer</code>. </td></tr>
    <tr><td class="paramname">The</td><td>offset from the released pointer where the finished <code>FlatBuffer</code> starts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A raw pointer to the start of the memory block containing the serialized <code>FlatBuffer</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the allocator is owned, it gets deleted during this call. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="flatbuffers_8h_source.html">flatbuffers.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-49880327-7', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
